> Ключевым компонентом любого компьютера является процессор — центральная и са- мая сложная микросхема, которая способна выполнять множество команд, которые все пронумерованы. Программы и данные хранятся в оперативной памяти, ячейки которых тоже пронумерованы (эти номера называют адресами). Таким образом, все команды процессора и ячейки памяти закодированы каким-либо числом. Создание программы с использованием номеров команды и адресов — это программирование в кодах.

[[PHP 8. Наиболее полное руководство [2023].pdf#page=129&selection=37,0,49,74|PHP 8. Наиболее полное руководство [2023], page 129]]

> Программировать в кодах достаточно сложно — в программах возникает множество ошибок, а люди плохо запоминают числа. Кроме того, с выходом нового процессора номера команд изменяются, и программу приходится составлять по-новой. Поэтому разработчики изобрели ассемблер — язык программирования, в котором числовые ко- ды команд были заменены на мнемоники: короткие буквенные сокращения, которые запоминать гораздо проще

[[PHP 8. Наиболее полное руководство [2023].pdf#page=131&selection=35,0,47,24|PHP 8. Наиболее полное руководство [2023], page 131]]

> потребовались языки программирования, не привязанные к конкретному про- цессору. Такие языки программирования получили название языков высокого уровня. Достаточно было адаптировать компилятор или интерпретатор такого языка под новый процессор, и на нем можно было запустить любую ранее написанную программу

[[PHP 8. Наиболее полное руководство [2023].pdf#page=132&selection=41,8,44,73|PHP 8. Наиболее полное руководство [2023], page 132]]

Программы и их сложность росли, и с этой сложностью нужно было бороться. Чем больше и сложнее программа, тем больше времени и денег уходит на ее создание, тем больше ошибок она содержит и тем сложнее вносить в нее изменения. Поэтому на сле- дующем этапе стали создаваться специализированные языки программирования, опе- рирующие не компьютерными терминами, а сущностями предметной области. Вместо адресов, указателей и файлов стало возможным манипулировать учетной ставкой, Глава 6. Классы и объекты 133 налогом, счетом, сотрудником. Составлять программы на языке предметной области оказалось гораздо удобнее: Список = Новый СписокЗначений(); Список.Добавить("ВвестиСчетФактуру", "Счет-фактура");

> Поэтому следующим этапом стало создание объектно-ориентированных языков про- граммирования. В рамках этой концепции вы сначала строите язык предметной облас- ти, а затем, используя его, уже решаете прикладную задачу. Ключевой сущностью в таких языках программирования является объект — специальным образом организо- ванный участок программы, который моделирует объекты реального мира. Точно так же, как в обычном мире, программные объекты могут взаимодействовать друг с дру- гом. Программировать на объектно-ориентированном языке гораздо удобнее, посколь- ку вместо того, чтобы оперировать объектами компьютера (файлы, память, адрес и т. п.) вы оперируете понятиями вашей предметной области. Так, если вы работаете над бухгалтерской программой, можно сначала разработать объект сотрудника, счета, заработной платы, а лишь затем собирать из этих объектов саму программу. В результате размер конечной программы будет короче. Разобраться в том, как она работает, будет проще, а при внесении изменений снизится вероятность совершить ошибку.

[[PHP 8. Наиболее полное руководство [2023].pdf#page=133&selection=17,0,38,17|PHP 8. Наиболее полное руководство [2023], page 133]]

> Класс — это элемент языка, который задает поведение объекта. Класс существует всегда в единственном экземпляре, но с его помощью можно создать множество объек- тов (рис. 6.3). Прибегая к классам, программист оперирует не машинными терминами (переменная), а объектами реального мира, поднимаясь тем самым на новый абстрактный уровень. Яблоки и людей нельзя складывать друг с другом, однако низкоуровневый код запро- сто позволит совершить такую логическую ошибку. При использовании классов эта операция становится невозможной или, по крайней мере, сильно затрудненной.

[[PHP 8. Наиболее полное руководство [2023].pdf#page=133&selection=50,0,59,74|PHP 8. Наиболее полное руководство [2023], page 133]]

> Язык программирования PHP включает большое количество готовых классов. Одним из таких классов является DateTime, который позволяет оперировать датой и временем. В листинге 6.1 приводится пример создания объекта $date класса DateTime. Объект соз- дается путем передачи названия класса конструкции new. В момент создания объекта $date он инициализируется текущими датой и временем. С объектами можно взаимодействовать, либо сохраняя в них значения, либо извлекая из них информацию. В реальной жизни объекты окружающего мира тоже имеют раз- ные состояния: машина неподвижна, стоит с запущенным двигателем, движется и т. п. Причем мы можем взаимодействовать с объектом и отдавать ему команды: включить двигатель, включить фары, открыть дверь. В программе для моделирования объекта применяются переменные, в которых мы со- храняем состояние объекта. Для отправки сигнала объекту используются функции, которые выполняют какие-то преобразования над переменными объекта (рис. 6.4). Переменные внутри объекта называются свойствами, а функции — методами. Свой- ства хранят состояния, методы — выполняют полезную работу или изменяют внутрен- нее состояние объекта.

[[PHP 8. Наиболее полное руководство [2023].pdf#page=134&selection=14,0,57,22|PHP 8. Наиболее полное руководство [2023], page 134]]

> Однако в объемных PHP-проектах создание и использование объ- ектов может происходить в разных файлах. В этом случае может быть полезна функция get_class(), которая имеет следующий синтаксис: get_class(object $object = ?): string Функция принимает в качестве параметра переменную с объектом $object, а в качестве результата возвращает название класса, при помощи которого она была создана. При попытке передать функции переменную с типом, отличным от object, возникает ошибка.

[[PHP 8. Наиболее полное руководство [2023].pdf#page=136&selection=4,21,41,7|PHP 8. Наиболее полное руководство [2023], page 136]]

> Начиная с версии PHP 8.0, имя класса объекта $object можно получить с использовани- ем альтернативного синтаксиса: $object::class

[[PHP 8. Наиболее полное руководство [2023].pdf#page=136&selection=42,0,50,36|PHP 8. Наиболее полное руководство [2023], page 136]]

> PHP-скрипты могут включаться в документ при помощи тегов <?php и ?>, и один доку- мент может содержать множество включений этих тегов. Однако класс должен объяв- ляться в одном неразрывном блоке <?php и ?>. Попытка разорвать объявление класса приводит к генерации интерпретатором ошибки PHP Parse error: syntax error, unexpected token ";", expecting "function" or "const". Так как прерывать объявление класса недопустимо, его не удастся разбить на несколь- ко файлов-частей и при помощи конструкций include() или require(). В теле класса могут быть объявлены переменные, которые так и называются: перемен- ными, или свойствами класса. Например, для задания точки координат на плоскости можно создать класс Point, содержащий две координаты: $x и $y (листинг 6.5). Клю- чевое слово public используется здесь для задания области видимости переменных и далее еще не раз встретится в этой главе.

[[PHP 8. Наиболее полное руководство [2023].pdf#page=137&selection=16,0,89,41|PHP 8. Наиболее полное руководство [2023], page 137]]

> Чтобы исключить повторное определение классов, вместо инструкций require и include используются инструкции require_once и include_once. Их отличие от оригинальных инструкций состоит в том, что они включают файл только один раз, а попытки повтор- ного включения файла игнорируются

[[PHP 8. Наиболее полное руководство [2023].pdf#page=139&selection=10,0,27,33|PHP 8. Наиболее полное руководство [2023], page 139]]

> При создании объекта после имени класса могут следовать необязательные круглые скоб- ки. Как будет показано в главе 14, в круглых скобках можно указывать параметры, инициа- лизирующие объект.

[[PHP 8. Наиболее полное руководство [2023].pdf#page=140&selection=62,0,67,18|PHP 8. Наиболее полное руководство [2023], page 140]]

> В отличие от других языков программирования, объект в PHP, объявленный внутри блока, ограниченного фигурными скобками, существует и за его пределами, не подвер- гаясь уничтожению при выходе из блока. Исключение составляет область видимости функции и класса.

[[PHP 8. Наиболее полное руководство [2023].pdf#page=141&selection=24,0,27,17|PHP 8. Наиболее полное руководство [2023], page 141]]

> То есть переменные действуют лишь в своей определенной области видимости, между которыми существуют как бы «водоразделы». В языке PHP такими водоразделами являются ключевые слова class и function, которые объявляют классы и функции/ме- тоды. Впрочем, существует множество механизмов для передачи значений за пределы этих границ, которые будут рассмотрены позже.

[[PHP 8. Наиболее полное руководство [2023].pdf#page=141&selection=67,0,78,45|PHP 8. Наиболее полное руководство [2023], page 141]]

 > Такую ситуацию можно было бы избежать, если ограничить возможность хранения в объектах класса Point зна- чений, отличных от числовых. Для этого перед переменными следует явно указать тип

[[PHP 8. Наиболее полное руководство [2023].pdf#page=142&selection=50,2,56,81|PHP 8. Наиболее полное руководство [2023], page 142]]

 > Начиная с PHP 8.0, можно использовать объединенные типы. Полученный ранее класс может работать только с целыми числами, а если возникает необходимость разрешить работу класса с целыми и вещественными числами, можно воспользоваться объедине- нием типов int|float

[[PHP 8. Наиболее полное руководство [2023].pdf#page=143&selection=37,0,42,9|PHP 8. Наиболее полное руководство [2023], page 143]]

> Тип ?int означает, что значение может принимать и целое число, и быть равным null. В листинге 6.23 приводится пример, в котором переменной $x присваивается значение null

[[PHP 8. Наиболее полное руководство [2023].pdf#page=144&selection=98,0,112,4|PHP 8. Наиболее полное руководство [2023], page 144]]

> Свойства и методы класса объявляются при помощи одного из ключевых слов: public, private или protected. Эти ключевые слова называются спецификаторами доступа и позволяют указать, какие элементы объекта доступны извне, а какие — нет. Открытые члены класса объявляются спецификатором доступа public и доступны как внутри класса, так и внешнему по отношению к классу коду. Закрытые методы и свой- ства класса объявляются при помощи спецификатора private и доступны только в рам- ках класса — обратиться к ним извне невозможно.

[[PHP 8. Наиболее полное руководство [2023].pdf#page=145&selection=30,0,64,47|PHP 8. Наиболее полное руководство [2023], page 145]]

> Начиная с версии PHP 8.1, классы поддерживают readonly-свойства — значение таких переменных можно прочитать, но нельзя установить

[[PHP 8. Наиболее полное руководство [2023].pdf#page=146&selection=50,0,54,48|PHP 8. Наиболее полное руководство [2023], page 146]]

> Порядок следования ключевых слов при объявлении переменной класса имеет значе- ние: сначала спецификатор доступа, потом readonly и лишь в конце тип. Изменение порядка приводит к ошибке. Более того, применять ключевое слово readonly можно только тогда, если явно указывается тип переменной. Если вам нужно создать readonly- свойство произвольного типа, следует использовать либо объединение типов, либо тип mixed

[[PHP 8. Наиболее полное руководство [2023].pdf#page=146&selection=70,0,88,1|PHP 8. Наиболее полное руководство [2023], page 146]]

> Можно задаться вопросом: как же задать значение этим переменным, если даже попыт- ка чтения неинициализированной переменной вызывает ошибку? Причем ошибку зако- номерную, т. к. readonly-свойство можно только читать, без предустановленного значе- ния оно всегда будет возвращать значение null. Поэтому использование такой пере- менной по большому счету бессмысленно. Дело же здесь в том, что свойство для чтения относится только к внешнему коду. Внутри класса такие свойства можно инициировать. Чтобы это сделать, придется забе- жать немного вперед и воспользоваться функциями внутри класса. Как уже упомина- лось в начале главы, такие функции называются методами. Внутри метода можно устанавливать любые переменные класса, в том числе закрытые и только для чтения. В листинге 6.29 приводится пример, в котором класс Greeting расширяется дополни- тельным методом setter(), а внутри метода readonly-переменной $hello назначается строковое значение 'PHP'

[[PHP 8. Наиболее полное руководство [2023].pdf#page=147&selection=60,0,97,5|PHP 8. Наиболее полное руководство [2023], page 147]]

> Было бы гораздо удобнее, если бы readonly-свойство было инициализировано сразу после создания объекта. Для этого в объектно-ориентированном программировании предназначены специальные методы — конструкторы. Если имя метода setter() мы выдумали самостоятельно, имена специальных методов определены интерпретатором PHP заранее. Чтобы в классе Greeting появился конструктор, необходимо объявить метод с именем __construct(

[[PHP 8. Наиболее полное руководство [2023].pdf#page=148&selection=54,0,75,12|PHP 8. Наиболее полное руководство [2023], page 148]]

> Однако допускается создание переменных на уровне класса. Такие переменные назы- ваются статическими и объявляются при помощи ключевого слова static. Особенно- стью этих переменных является возможность их инициализации прямо в классе при объявлении

[[PHP 8. Наиболее полное руководство [2023].pdf#page=150&selection=27,0,37,10|PHP 8. Наиболее полное руководство [2023], page 150]]

> Обращаться к таким переменным можно без создания объектов с помощью оператора разрешения области видимости ::

[[PHP 8. Наиболее полное руководство [2023].pdf#page=150&selection=51,0,54,2|PHP 8. Наиболее полное руководство [2023], page 150]]

> Оператор присвоения = не приводит к созданию новой копии объекта: и старый, и новый объект указывают на одну и ту же область памяти

[[PHP 8. Наиболее полное руководство [2023].pdf#page=151&selection=34,0,40,27|PHP 8. Наиболее полное руководство [2023], page 151]]

> Однако, если все же создание копии текущего объекта необходимо, используется спе- циальная операция — клонирование. Она выполняется при помощи ключевого слова clone, которое располагается непосредственно перед объектом клонирования

[[PHP 8. Наиболее полное руководство [2023].pdf#page=152&selection=37,0,44,67|PHP 8. Наиболее полное руководство [2023], page 152]]


