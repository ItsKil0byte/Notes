> Начнем c переменных — синтаксических конструкций, которые позволяют сохранять значения в оперативную память компьютера (рис. 5.1). В программе для создания, из- менения или чтения значения переменной используется имя переменной. В качестве значений переменных могут выступать введенные пользователем или вычисленные в программе числа, строки или логические величины. К разным видам значений могут применяться разные операторы и функции. Чтобы интерпретатор мог «понимать», когда к переменной допустимо применять ту или иную конструкцию языка, каждая переменная помечается типом. Например, строка помечается типом string, а целое число — типом integer. Помимо базовых типов, которые могут хранить лишь одно значение, PHP предоставля- ет составные типы: массивы, объекты, ресурсы. Такие типы хранят в одной переменной множество значений и часто строятся как комбинация нескольких базовых типов.

[[PHP 8. Наиболее полное руководство [2023].pdf#page=93&selection=18,0,45,76|PHP 8. Наиболее полное руководство [2023], page 93]]

> Как и в любом другом языке программирования, в PHP существует такое понятие, как переменная. Под переменной мы будем понимать именованную область оперативной памяти компьютера. Переменная нужна для того, чтобы сохранить в ней значение в одной части программы, а затем, используя имя этой переменной, извлечь это значе- ние в другой. Можно рассматривать переменную как буфер обмена компьютера, только в программе допускается неограниченное количество таких буферов.

[[PHP 8. Наиболее полное руководство [2023].pdf#page=94&selection=14,0,21,64|PHP 8. Наиболее полное руководство [2023], page 94]]

> Названия переменных начинаются со знака доллара ($), за которым может следовать любое количество буквенно-цифровых символов и символов подчеркивания, но первый

[[PHP 8. Наиболее полное руководство [2023].pdf#page=94&selection=119,0,122,79|PHP 8. Наиболее полное руководство [2023], page 94]]

> В отличие от других языков программирования, наличие специального символа долла- ра в начале ($) снимает проблему совпадения названия переменной с ключевыми сло- вами.

[[PHP 8. Наиболее полное руководство [2023].pdf#page=95&selection=33,0,37,5|PHP 8. Наиболее полное руководство [2023], page 95]]

> В отличие от других языков программирования, наличие специального символа долла- ра в начале ($) снимает проблему совпадения названия переменной с ключевыми сло- вами.

[[PHP 8. Наиболее полное руководство [2023].pdf#page=95&selection=33,0,37,5|PHP 8. Наиболее полное руководство [2023], page 95]]

> В отличие от других языков программирования, наличие специального символа долла- ра в начале ($) снимает проблему совпадения названия переменной с ключевыми сло- вами.

[[PHP 8. Наиболее полное руководство [2023].pdf#page=95&selection=33,0,37,5|PHP 8. Наиболее полное руководство [2023], page 95]]

> Тип — это набор свойств и синтаксических особенностей значений переменных, кото- рые определяют поведение переменной. В программе можно объявить несколько пере- менных одного типа (рис. 5.3). Создать собственный базовый тип невозможно — его определяет интерпретатор языка. Правда, допускается создание классов, которые, как мы увидим позже, очень похожи на встроенные типы.

[[PHP 8. Наиболее полное руководство [2023].pdf#page=97&selection=16,0,25,49|PHP 8. Наиболее полное руководство [2023], page 97]]

> Как видим, в программе типы переменных integer и string не упоминаются явно. Они задаются природой значения. Более того, переменная, объявленная строкой, может ис- пользоваться далее в арифметических операциях и выступать как логическая перемен- ная, а в конце ей в качестве значения может быть присвоен объект. Все это позволяет разработчику практически не задумываться о типах данных. Поэтому язык PHP относят к слабо типизированным: в большинстве случаев перемен- ные языка не требуют строго задания типа при их объявлении, а в ходе выполнения программы тип переменной может быть практически всегда изменен неявным образом без специальных преобразований

[[PHP 8. Наиболее полное руководство [2023].pdf#page=98&selection=12,0,28,30|PHP 8. Наиболее полное руководство [2023], page 98]]

> Различают базовые типы переменных:  integer — целые числа;  float — вещественные числа или числа с плавающей точкой;  boolean — логические значения;  string — строки;  null — неопределенное значение. Для каждого из этих типов интерпретатор предоставляет встроенные средства создания значений — например, кавычки для строк или цифры для чисел. Главной характери- стикой базовых типов является сохранение единственного значения в переменной. В отличие от базовых, составные типы позволяют хранить в одной переменной множе- ство значений. К этим типам можно отнести следующие:  array — массивы;  object — объекты;  resource — ресурсы. Для создания массивов и объектов PHP предоставляет синтаксические конструкции. Ресурсы можно создать лишь неявным способом — как правило, их создает сторонняя библиотека/расширение, и со стороны PHP-программы на ресурс можно влиять лишь отчасти — настолько, насколько позволяет сторонняя библиотека. Типы callable, void, iterable, mixed и never часто называют псевдотипами, т. к. создать переменную этого типа невозможно. Псевдотипы void и never вообще означают отсут- ствие какого-либо значения. Однако эти типы интенсивно используются для обозначе- ния типа параметров и возвращаемых значений в функциях

[[PHP 8. Наиболее полное руководство [2023].pdf#page=99&selection=56,0,153,54|PHP 8. Наиболее полное руководство [2023], page 99]]

> Такие обозначения для смешанных типов присутствовали в документации языка и раньше, однако, начиная с версии PHP 8.0, можно объявлять свои собственные пере- менные с использованием двух или более типов.

[[PHP 8. Наиболее полное руководство [2023].pdf#page=100&selection=33,0,35,45|PHP 8. Наиболее полное руководство [2023], page 100]]

> Начиная с версии PHP 8.1, поддерживаются пересечения — например, Countable&Stringable. Такое пересечение требует, чтобы переменная одновременно удовлетворяла ограничениям и Countable, и Stringable. Это невозможно в случае базо- вых типов и применяется в объектно-ориентированном программировании

[[PHP 8. Наиболее полное руководство [2023].pdf#page=100&selection=40,0,75,67|PHP 8. Наиболее полное руководство [2023], page 100]]

> В отличие от других языков программирования, переполнения в PHP не бывает. Перепол- нение — это ошибка, связанная с выходом значения за допустимые границы, когда число не умещается в переменной заданного типа. Если такая ситуация возникает в PHP — на- пример, значение не умещается в integer, для него автоматически выбирается больший тип данных (float).

[[PHP 8. Наиболее полное руководство [2023].pdf#page=100&selection=94,0,107,2|PHP 8. Наиболее полное руководство [2023], page 100]]

> Константы true и false не зависят от регистра. Синтаксис PHP допускает использование регистронезависимых вариантов: True и TRUE. Однако стандарт оформления программ на PHP требует записи констант строчными буквами: true и false. Более подробно константы обсуждаются в главе 7

[[PHP 8. Наиболее полное руководство [2023].pdf#page=104&selection=58,0,86,1|PHP 8. Наиболее полное руководство [2023], page 104]]

> В PHP функциональность двойных кавычек расширена. Так, если поместить в двойные кавычки переменную, ее значение будет подставлено в текст (листинг 5.21). Такая под- становка называется интерполяцией.

[[PHP 8. Наиболее полное руководство [2023].pdf#page=106&selection=14,0,19,1|PHP 8. Наиболее полное руководство [2023], page 106]]

> Иногда требуется подавить такую подстановку. Для этого применяется экранирование символа $ обратным слешем, как это показано в листинге 5.22.

[[PHP 8. Наиболее полное руководство [2023].pdf#page=106&selection=27,0,35,50|PHP 8. Наиболее полное руководство [2023], page 106]]

> Размещение переменных и специальных символов (за исключением \') в одиночных кавычках не приводит к их специальной интерпретации

[[PHP 8. Наиболее полное руководство [2023].pdf#page=107&selection=24,0,25,51|PHP 8. Наиболее полное руководство [2023], page 107]]

> Объявить строку можно, не прибегая к кавычкам. Для этого используется опера- тор <<<, который еще называют встроенным документом (here-документ). Сразу после такой последовательности размещается метка (маркер), а конец оператора обозначается повторным вхождением метки

[[PHP 8. Наиболее полное руководство [2023].pdf#page=108&selection=108,0,115,26|PHP 8. Наиболее полное руководство [2023], page 108]]

> Строка — это составной объект, представляющий собой коллекцию отдельных симво- лов. Получается, что строка — не просто значение, как 1 и 2, а несколько последова- тельных значений. Если поменять местами две буквы, мы получим уже другую строку

[[PHP 8. Наиболее полное руководство [2023].pdf#page=109&selection=22,0,26,79|PHP 8. Наиболее полное руководство [2023], page 109]]

Массив (ассоциативный массив) — это набор из нескольких элементов, представляю- щих собой пару вида ключ=>значение. Символом => мы обозначаем соответствие опреде- ленному ключу какого-то значения. Глава 5. Переменные и типы данных 111 Доступ к отдельным элементам массива осуществляется указанием их ключа. В отли- чие от C-массивов, ключами здесь могут служить не только целые числа, но и любые строки

> Переменные этого типа содержат в качестве значения сложные структуры — объекты, которые можно рассматривать как контейнеры для переменных и функций, обрабаты- вающих значения в контейнере. Внутренняя структура объекта похожа на ассоциативный массив, за исключением того, что для доступа к отдельным элементам (свойствам) и функциям (методам) объекта используется оператор ->, а не квадратные скобки.

[[PHP 8. Наиболее полное руководство [2023].pdf#page=111&selection=42,0,53,25|PHP 8. Наиболее полное руководство [2023], page 111]]

> Переменные этого типа содержат в качестве значения структуру в памяти, которую PHP обрабатывает особым образом. Пример ресурса — переменная, содержащая деск- риптор открытого файла. Такая переменная в дальнейшем может быть использована для того, чтобы указать PHP, с каким файлом нужно провести ту или иную операцию (например, прочитать строку). Другой пример: функция imageCreate() графической библиотеки GD создает в памяти новую «пустую» картинку указанного размера и воз- вращает ее идентификатор. Используя этот идентификатор, вы можете манипулировать картинкой — например, нарисовать в ней линию или вывести текст, а затем сохранить результат в PNG- или JPEG-файл. Впрочем, начиная с версии PHP 8.0, ресурсы активно заменяются на встроенные классы. Возможно, в ближайших версиях PHP вообще не останется такого типа

[[PHP 8. Наиболее полное руководство [2023].pdf#page=111&selection=69,0,83,21|PHP 8. Наиболее полное руководство [2023], page 111]]

> Специальный тип null предназначен для пометки неинициализированной переменной. Для инициализации переменной этого типа можно использовать специальную констан- ту null

[[PHP 8. Наиболее полное руководство [2023].pdf#page=112&selection=8,0,16,4|PHP 8. Наиболее полное руководство [2023], page 112]]

> Следует отметить, что при инициализации переменной при помощи константы null и последующем обращении к этой переменной в выражениях не происходит генерации замечания PHP Warning: Undefined variable. Это связано с особенностью работы интерпретатора PHP: любое выражение вида $var = ..., которое встречается в программе, приводит к регистрации переменной во внутренней таблице имен. В случае, если переменная получает значение null, выделе- ния памяти под значение не происходит, однако имя переменной регистрируется. При любом обращении к переменным PHP проверяет наличие переменной в таблице имен. Если переменная не обнаружена, возникает предупреждение PHP Warning: Undefined variable

[[PHP 8. Наиболее полное руководство [2023].pdf#page=112&selection=32,0,62,8|PHP 8. Наиболее полное руководство [2023], page 112]]

> Переменная может быть уничтожена при помощи конструкции unset(). После этого переменная удаляется из внутренних таблиц интерпретатора — т. е. программа начина- ет выполняться так, как будто переменная еще не была инициализирована

[[PHP 8. Наиболее полное руководство [2023].pdf#page=113&selection=15,0,36,16|PHP 8. Наиболее полное руководство [2023], page 113]]

> Впрочем, unset() редко применяется к обычным переменным. Полезнее использовать эту конструкцию для удаления отдельного элемента массива — чтобы, например, осво- бодить память. Так, если из массива $programs нужно удалить элемент с ключом angel, это можно сделать следующим образом: unset($programs["angel"]); Теперь элемент angel не просто стал пустым, а именно удалился, и последующий про- смотр массива его не обнаружит.

[[PHP 8. Наиболее полное руководство [2023].pdf#page=113&selection=60,0,86,31|PHP 8. Наиболее полное руководство [2023], page 113]]

> Как видно из предыдущих разделов, в произвольной точке скрипта переменная может оказаться неинициализированной или уничтоженной к этому времени вызовом unset(). Для проверки существования переменной служит конструкция isset()

[[PHP 8. Наиболее полное руководство [2023].pdf#page=113&selection=90,0,97,7|PHP 8. Наиболее полное руководство [2023], page 113]]

> пустая строка — это полноценная переменная, и она не эквивалентна неинициализированной переменной (т. е. переменной, принимающей значение null). Для проверки, является ли строка пустой или нет, предназначена специ- альная конструкция empty()

[[PHP 8. Наиболее полное руководство [2023].pdf#page=114&selection=61,29,79,7|PHP 8. Наиболее полное руководство [2023], page 114]]

> Кроме описанных в предыдущих разделах действий, существует еще несколько стан- дартных функций, которые занимаются определением типа переменных и часто вклю- чаются в условные операторы

[[PHP 8. Наиболее полное руководство [2023].pdf#page=115&selection=64,0,66,27|PHP 8. Наиболее полное руководство [2023], page 115]]

> Следуя оригинальной документации PHP, мы будем указывать типы переменных и функций там, где это необходимо. Вот пример описания функции gettype() из преды- дущего раздела: gettype(mixed $value): string Функция принимает единственный параметр $value любого типа (mixed), при этом воз- вращает строку (тип string). Если какой-то элемент в синтаксическом описании является необязательным, он за- ключается в квадратные скобки. Например, конструкция unset() способна принимать в качестве аргумента несколько значений, и ее описание тогда может выглядеть сле- дующим образом: unset(mixed $var, [mixed ...$vars]): void То есть все аргументы unset() могут быть произвольного типа (mixed). Допускается любое количество аргументов, но не менее одного. Бесконечное количество аргументов задается последовательностью ..., которая более подробно рассматривается в главе 12. Конструкция ничего не возвращает в качестве результата тип void.

[[PHP 8. Наиболее полное руководство [2023].pdf#page=116&selection=134,0,181,1|PHP 8. Наиболее полное руководство [2023], page 116]]

> Помимо неявного преобразования типов разработчику может потребоваться явно пре- образовать ту или иную переменную в один из типов, поддерживаемых PHP. Для тако- го преобразования предусмотрено несколько механизмов. Первый из них заключается в использовании круглых скобок. В них указывается тип, к которому следует привести переменную

[[PHP 8. Наиболее полное руководство [2023].pdf#page=118&selection=86,0,90,38|PHP 8. Наиболее полное руководство [2023], page 118]]

> Помимо оператора круглых скобок PHP предоставляет ряд специальных функций, по- зволяющих осуществить преобразование типа переменной, и в частности функцию settype(): settype(mixed $var, string $type): bool Функция settype() является универсальной функцией преобразования типов и преобра- зует переменную $var к типу, указанному в параметре $type, который может принимать одно из следующих значений: "boolean", "bool", "integer", "int", "double", "string", "array", "object" и "null". Функция возвращает true, если преобразование было успеш- но осуществлено, и false в противном случае

[[PHP 8. Наиболее полное руководство [2023].pdf#page=120&selection=4,0,61,18|PHP 8. Наиболее полное руководство [2023], page 120]]

> Однако использование функции settype() не очень удобно из-за того, что она возвра- щает логическое значение, а не результат преобразования. На практике, если в явном преобразовании возникает необходимость, гораздо удобнее пользоваться специализи- рованными функциями: floatval(), doubleval(), intval() и strval(). В листинге 5.46 на примере функции intval() демонстрируется использование функций этого класса.

[[PHP 8. Наиболее полное руководство [2023].pdf#page=120&selection=85,0,110,51|PHP 8. Наиболее полное руководство [2023], page 120]]

> В начале главы мы определили переменные как именованную область памяти. При этом имя переменной в программе указывает на какое-то значение в оперативной памя- ти компьютера. Что произойдет, если две переменные будут указывать на одну и ту же область памяти? В этом случае изменение значения одной переменной будет приводить к автоматическому изменению другой переменной. Организовать такую связь двух или более переменных можно разными способами, а сами переменные называются ссылка- ми. Существуют три разновидности ссылок: жесткие, символические и ссылки на объ- екты.

[[PHP 8. Наиболее полное руководство [2023].pdf#page=121&selection=62,0,72,5|PHP 8. Наиболее полное руководство [2023], page 121]]

> Жесткая ссылка представляет собой просто переменную, которая является синонимом другой переменной. Чтобы создать жесткую ссылку, нужно использовать оператор &

[[PHP 8. Наиболее полное руководство [2023].pdf#page=121&selection=76,0,82,1|PHP 8. Наиболее полное руководство [2023], page 121]]

> В результате выполнения этой программы, хотя ссылке $b и не было ничего присвоено, в массиве $arr создастся новый элемент с ключом 'ложка' и значением null. То есть жесткая ссылка на самом деле не может ссылаться на несуществующий «объект», а если делается такая попытка, то объект создается.

[[PHP 8. Наиболее полное руководство [2023].pdf#page=122&selection=42,0,60,49|PHP 8. Наиболее полное руководство [2023], page 122]]

> Оператор unset($r), выполненный для жесткой ссылки, не удаляет из памяти «объект», на который она ссылается, и не освобождает память. Он всего лишь разрывает связь между ссылкой и «объектом» и ликвидирует запись о переменной $r из своих таблиц. И в самом деле — он не может уничтожить «объект»: ведь $a до сих пор ссылается на него. Итак, жесткая ссылка и переменная (объект), на которую она ссылается, совершенно равноправны: изменение одной влечет изменение другой. Оператор unset() разрывает связь между объектом и ссылкой, но объект удаляется только тогда, когда на него ни- кто уже не ссылается. Такой алгоритм, когда объекты удаляются только после потери последней ссылки на них, традиционно называют алгоритмом сбора мусора.

[[PHP 8. Наиболее полное руководство [2023].pdf#page=123&selection=35,0,63,1|PHP 8. Наиболее полное руководство [2023], page 123]]

> Символическая ссылка — это всего лишь строковая переменная, хранящая имя другой переменной. Чтобы добраться до значения переменной, на которую указывает симво- лическая ссылка, необходимо применить оператор разыменования — дополнительный знак $ перед именем ссылки

[[PHP 8. Наиболее полное руководство [2023].pdf#page=123&selection=67,0,80,19|PHP 8. Наиболее полное руководство [2023], page 123]]

> Копирование объектов и массивов в PHP осуществляется по ссылке. 

[[PHP 8. Наиболее полное руководство [2023].pdf#page=124&selection=6,0,6,64|PHP 8. Наиболее полное руководство [2023], page 124]]

> Так как переменные содержат лишь ссылки на объекты, при их присваивании копиру- ются только эти ссылки, но не сами объекты. Это довольно просто понять: вы можете сдать в гардероб свое пальто (объект) и получить на него номерок (ссылку), а затем пойти к мастеру номерков и сделать дубликат. У вас будет два номерка, но пальто, конечно, останется в единственном экземпляре, так что вам не удастся сколотить состояние на этой махинации, сколько бы вы ее ни проделывали

[[PHP 8. Наиболее полное руководство [2023].pdf#page=124&selection=57,0,62,60|PHP 8. Наиболее полное руководство [2023], page 124]]

> в PHP существуют три функции, которые позволяют легко вывести в браузер содержимое любой переменной, сколь бы сложным оно ни было. Это касается массивов, объектов, скалярных переменных и даже константы null. Одной из самых популярных отладочных функций является print_r(), которая имеет следующий синтаксис: print_r(mixed $value, bool $return = false): string|bool Функция принимает переменную или выражение $value и выводит ее отладочное пред- ставление

[[PHP 8. Наиболее полное руководство [2023].pdf#page=125&selection=17,49,36,9|PHP 8. Наиболее полное руководство [2023], page 125]]

> Функция var_dump()очень похожа на print_r()и имеет следующий синтаксис: var_dump(mixed $value, mixed ...$values): void Эта функция выводит не только значения переменных и массивов, но также и инфор- мацию об их типах

[[PHP 8. Наиболее полное руководство [2023].pdf#page=126&selection=60,0,71,17|PHP 8. Наиболее полное руководство [2023], page 126]]

> Функция var_export() напоминает print_r(), но только она выводит значение перемен- ной так, что оно может быть использовано как «кусок» PHP-программы. Функция име- ет следующий синтаксис: var_export(mixed $value, bool $return = false): ?string

[[PHP 8. Наиболее полное руководство [2023].pdf#page=127&selection=18,0,29,55|PHP 8. Наиболее полное руководство [2023], page 127]]

