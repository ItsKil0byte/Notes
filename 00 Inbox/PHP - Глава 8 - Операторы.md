> Правила хорошего тона предписывают по возможности применять одиночные кавычки для создания строк, в которых не используется интерполяция. В тех же случаях, когда в строку интерполируется переменная PHP, применяются двойные кавычки. Впрочем, это правило не строгое и часто нарушается, особенно если содержимое строки включа- ет один из вариантов кавычек. Многочисленное экранирование внутри строки может значительно затруднять восприятие программы. Помимо оператора «точка» (.) существует оператор .=, который предназначен для сокращения конструкции $str = $str . $newstring до $str .= $newstring.

[[PHP 8. Наиболее полное руководство [2023].pdf#page=164&selection=20,0,51,1|PHP 8. Наиболее полное руководство [2023], page 164]]

> Во многих языках программирования для объединения строк используется оператор +. В PHP это не так — при использовании строк в выражении с оператором + интерпрета- тор пытается автоматически привести строку к числовому значению

[[PHP 8. Наиболее полное руководство [2023].pdf#page=164&selection=71,0,80,63|PHP 8. Наиболее полное руководство [2023], page 164]]

> Оператор запятая используется в тех случаях, когда необходимы списки значений. Проще всего этот оператор рассмотреть на примере одной из конструкций PHP. Конструкция echo предназначена для вывода переменных в окно браузера и уже много- кратно использовалась в предыдущих главах. Конструкция имеет следующий синтак- сис: echo string ...$expressions : void Она может принимать один или более разделенных запятой параметров, которые выво- дит в окно браузера. В листинге 8.2 приводился пример, в котором три строки объеди- нялись в одну перед выводом их конструкцией echo. Однако то же самое можно сде- лать, просто записав все параметры после echo через запятую

[[PHP 8. Наиболее полное руководство [2023].pdf#page=166&selection=6,0,28,13|PHP 8. Наиболее полное руководство [2023], page 166]]

> В отличие от многих других языков программирования, если при операции деления одного целого числа на другое получается дробное число, в PHP результат автоматиче- ски приводится к вещественному типу

[[PHP 8. Наиболее полное руководство [2023].pdf#page=168&selection=9,0,11,35|PHP 8. Наиболее полное руководство [2023], page 168]]

> В зависимости от количества участвующих в операции операндов операции подразделяют на унарные и бинарные: унарная операция работает с одним операндом, бинарная — с двумя. Все арифметические операции, кроме операций инкремента и декремента, явля- ются бинарными. Существует также условная операция, в которой используются три опе- ранда

[[PHP 8. Наиболее полное руководство [2023].pdf#page=169&selection=60,0,72,5|PHP 8. Наиболее полное руководство [2023], page 169]]

> Операторы инкремента (++) и декремента (--) подразделяют на префиксные и пост- фиксные. При префиксной операции инкремента увеличение значения операнда на еди- ницу происходит до того, как возвращается значение. Соответственно при постфикс- ной — после

[[PHP 8. Наиболее полное руководство [2023].pdf#page=169&selection=86,0,99,1|PHP 8. Наиболее полное руководство [2023], page 169]]

> Битовые, или поразрядные, операторы предназначены для работы (установки, снятия и проверки) групп битов в целой переменной. Биты целого числа — это не что иное, как отдельные разряды того же самого числа, записанного в двоичной системе счисления. Например, в двоичной системе число 12 будет выглядеть как 1100, а 2 — как 10, так что выражение 12|2 вернет нам число 14

[[PHP 8. Наиболее полное руководство [2023].pdf#page=170&selection=88,0,96,19|PHP 8. Наиболее полное руководство [2023], page 170]]

Числа 3, 28, 16352, 8372224 и 4286578688, задействованные в листинге 8.22, называют- ся битовыми масками. Маска содержит единицы в том регионе, который необходимо Глава 8. Операторы 175 извлечь, и нули во всех остальных положениях. Поразрядное пересечение маски с чис- лом приводит к тому, что в результате остаются только значащие биты извлекаемого региона, а все остальные биты обнуляются.

> Операторы сравнения — это в своем роде уникальные операторы, потому что незави- симо от типов своих аргументов они всегда возвращают одно из двух значений: false или true. Операции сравнения позволяют сравнивать два значения между собой и, если условие выполнено, возвращают true, в противном случае — false. Исключение со- ставляет лишь оператор <=>, который возвращает целое число

[[PHP 8. Наиболее полное руководство [2023].pdf#page=176&selection=40,0,59,32|PHP 8. Наиболее полное руководство [2023], page 176]]

$x < $y Оператор «меньше», возвращает true, если переменная $x имеет значение строго меньше, чем значение $y $x <= $y Оператор «меньше или равно», возвращает true, если переменная $x имеет значение меньше или равное $y $x > $y Оператор «больше», возвращает true, если переменная $x имеет значение строго больше, чем значение $y $x >= $y Оператор «больше или равно», возвращает true, если переменная $x имеет значение больше или равное $y $x == $y Оператор равенства, возвращает true, если значение переменной $x равно $y $x != $y Оператор неравенства, возвращает true, если значение переменной $x не равно $y $x <> $y Эквивалентен оператору != $x === $y Оператор эквивалентности, возвращает true, если значение и тип перемен- ной $x равны $y $x !== $y Оператор неэквивалентности, возвращает true, если либо значение, либо тип переменной $x не соответствует переменной $y $x <=> $y В случае равенства переменных оператор возвращает 0, если $x больше $y, возвращается положительное число, если меньше — отрицательное 

> Запустив этот сценарий, вы увидите, что отображается только вторая строка! Выходит, не все так просто: с точки зрения PHP константа 1 и значение true не идентичны. Мы видим, что в операторах сравнения (на равенство \==, а также на неравенство !=) PHP интерпретирует один из операндов как логический, если другой — логический исходно. Иными словами, сравнивая что-то с true или false явно, мы всегда имеем в виду логи- ческое сравнение, так что 100 == true, а 0 == false. Но это еще не все. Вы будете, возможно, удивлены, что следующая команда: php > if (42 == ' 42') echo 'совпадение!'; печатает слово совпадение!, хотя мы сравниваем строку с числом, а они, очевидно, никак не равны в обычном смысле! Отсюда мы приходим ко второму правилу: если один из операндов оператора сравнения числовой, то сравнение всегда выполняется в числовом контексте, даже если второй операнд — не число

[[PHP 8. Наиболее полное руководство [2023].pdf#page=177&selection=50,0,106,1|PHP 8. Наиболее полное руководство [2023], page 177]]

> На практике сравнение вещественных чисел проводят путем вычитания их друг из друга и сравнения результата с заведомо не- большой величиной. Чтобы не зависеть от знака, результат вычитания сравниваемых значений пропускают через функцию abs(), которая возвращает модуль числа, т. е. убирает знак

[[PHP 8. Наиболее полное руководство [2023].pdf#page=178&selection=74,42,81,12|PHP 8. Наиболее полное руководство [2023], page 178]]

> Процедуры сравнения чисел и строк отличаются друг от друга. Дело в том, что строки в большинстве европейских языков читаются слева направо, в то время как разряды арабских цифр отсчитываются справа налево (рис. 8.11). При сравнении двух строк последовательно сравниваются коды отдельных символов. В случае английских символов эти коды можно получить при помощи функции ord()

[[PHP 8. Наиболее полное руководство [2023].pdf#page=179&selection=59,0,65,5|PHP 8. Наиболее полное руководство [2023], page 179]]

> Подводя итог, можно сделать такой вывод: две переменные равны в смысле \==, если «на глаз» они хранят одинаковые величины.

[[PHP 8. Наиболее полное руководство [2023].pdf#page=181&selection=87,0,91,41|PHP 8. Наиболее полное руководство [2023], page 181]]

> оэтому, если при сравнении переменных важно учитывать не только их значения, но и тип, вместо оператора сравнения используют оператор эквивалентности === (трой- ное равенство)

[[PHP 8. Наиболее полное руководство [2023].pdf#page=182&selection=24,5,30,14|PHP 8. Наиболее полное руководство [2023], page 182]]





